{"version":3,"sources":["webpack:///./node_modules/immer/dist/immer.module.js"],"names":["_a","Archtype","ProxyType","hasSymbol","Symbol","hasMap","Map","hasSet","Set","NOTHING","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","isDraft","value","isDraftable","proto","getPrototypeOf","isPlainObject","isArray","isMap","isSet","original","base","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","each","iter","getArchtype","forEach","key","entry","index","thing","die","type","ES5Object","ProxyObject","ES5Array","ProxyArray","has","prop","call","get","is","x","y","target","latest","state","copy","shallowCopy","invokeGetters","slice","clone","create","desc","getOwnPropertyDescriptor","Error","enumerable","defineProperty","writable","configurable","freeze","deep","isFrozen","add","clear","delete","dontMutateFrozenCollections","set","_","ImmerScope","parent","immer","drafts","canAutoFreeze","usePatches","patchListener","patches","inversePatches","revoke","leave","current","enter","scope","draft","revoked","processResult","result","baseDraft","isReplaced","undefined","willFinalize","modified","maybeFreeze","finalize","push","op","path","finalizeTree","finalized","onDelete","useProxies","assigned","exists","copy_1","onCopy","autoFreeze","basePath","assignedValue","origValue","generatePatchesFromAssigned","_b","length","delta","start","end","i","replaceCount","generateArrayPatches","unshift","generateSetPatches","generatePatches","root","rootPath","finalizeProperty","rootState","parentValue","childValue","isDraftProp","isSetMember","propOrOldValue","grandChild","onAssign","objectTraps","peek","createProxy","baseValue","prepareCopy","markChanged","deleteProperty","owner","arrayTraps","willFinalizeES5","finalizing","markChangesSweep","markChangesRecursively","object","markChangedES5","hasArrayChanges","createES5Proxy","clonePotentialDraft","descriptors","assertUnrevoked","peek$1","prepareCopy$1","get$1","set$1","proxyProperty","isEnumerable","isManual","fn","arguments","apply","isNaN","parseInt","JSON","stringify","hasObjectChanges","keys","state_1","descriptor","DraftMap","_super","size","prepareCopy$2","_i","cb","thisArg","_this","_value","_map","values","next","r","done","entries","DraftSet","prepareCopy$3","applyPatches","patch","join","deepClonePatchValue","splice","map","from","cloned","__spreadArrays","s","il","k","a","j","jl","configDefaults","Proxy","revocable","process","name","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","defaultBase_1","self_1","arguments$1","args","scope_1","proxy","hasError","Promise","then","error","arg1","arg2","arg3","ip","createDraft","finishDraft","setAutoFreeze","proxyMap","proxySet","traps","applyPatches$1"],"mappings":"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","file":"vendors~vendor-3bafe594.js","sourcesContent":["// Should be no imports here!\nvar _a; // SOme things that should be evaluated before all else...\n\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = hasSymbol ? Symbol(\"immer-nothing\") : (_a = {}, _a[\"immer-nothing\"] = true, _a);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = hasSymbol ? Symbol(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? Symbol(\"immer-state\") : \"__$immer_state\";\nvar iteratorSymbol = hasSymbol ? Symbol.iterator : \"@@iterator\";\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }\n  };\n\n  return extendStatics(d, b);\n}; // Ugly hack to resolve #502 and inherit built in Map / Set\n\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = ( // @ts-ignore\n  __.prototype = b.prototype, new __());\n}\n\nvar Archtype;\n\n(function (Archtype) {\n  Archtype[Archtype[\"Object\"] = 0] = \"Object\";\n  Archtype[Archtype[\"Array\"] = 1] = \"Array\";\n  Archtype[Archtype[\"Map\"] = 2] = \"Map\";\n  Archtype[Archtype[\"Set\"] = 3] = \"Set\";\n})(Archtype || (Archtype = {}));\n\nvar ProxyType;\n\n(function (ProxyType) {\n  ProxyType[ProxyType[\"ProxyObject\"] = 0] = \"ProxyObject\";\n  ProxyType[ProxyType[\"ProxyArray\"] = 1] = \"ProxyArray\";\n  ProxyType[ProxyType[\"ES5Object\"] = 2] = \"ES5Object\";\n  ProxyType[ProxyType[\"ES5Array\"] = 3] = \"ES5Array\";\n  ProxyType[ProxyType[\"Map\"] = 4] = \"Map\";\n  ProxyType[ProxyType[\"Set\"] = 5] = \"Set\";\n})(ProxyType || (ProxyType = {}));\n\n/** Returns true if the given value is an Immer draft */\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n/** Get the underlying object that is represented by the given draft */\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\nfunction each(obj, iter) {\n  if (getArchtype(obj) === Archtype.Object) {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return desc && desc.enumerable ? true : false;\n}\nfunction getArchtype(thing) {\n  /* istanbul ignore next */\n  if (!thing) { die(); }\n\n  if (thing[DRAFT_STATE]) {\n    switch (thing[DRAFT_STATE].type) {\n      case ProxyType.ES5Object:\n      case ProxyType.ProxyObject:\n        return Archtype.Object;\n\n      case ProxyType.ES5Array:\n      case ProxyType.ProxyArray:\n        return Archtype.Array;\n\n      case ProxyType.Map:\n        return Archtype.Map;\n\n      case ProxyType.Set:\n        return Archtype.Set;\n    }\n  }\n\n  return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  // @ts-ignore\n  return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  switch (getArchtype(thing)) {\n    case Archtype.Map:\n      thing.set(propOrOldValue, value);\n      break;\n\n    case Archtype.Set:\n      thing.delete(propOrOldValue);\n      thing.add(value);\n      break;\n\n    default:\n      thing[propOrOldValue] = value;\n  }\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy || state.base;\n}\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) {\n    invokeGetters = false;\n  }\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction freeze(obj, deep) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n  var type = getArchtype(obj);\n\n  if (type === Archtype.Set) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (type === Archtype.Map) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) {\n    return freeze(value, true);\n  }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n/* istanbul ignore next */\n\nfunction die() {\n  throw new Error(\"Illegal state, please file a bug\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope =\n/** @class */\nfunction () {\n  function ImmerScope(parent, immer) {\n    this.drafts = [];\n    this.parent = parent;\n    this.immer = immer; // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n\n    this.canAutoFreeze = true;\n  }\n\n  ImmerScope.prototype.usePatches = function (patchListener) {\n    if (patchListener) {\n      this.patches = [];\n      this.inversePatches = [];\n      this.patchListener = patchListener;\n    }\n  };\n\n  ImmerScope.prototype.revoke = function () {\n    this.leave();\n    this.drafts.forEach(revoke); // @ts-ignore\n\n    this.drafts = null;\n  };\n\n  ImmerScope.prototype.leave = function () {\n    if (this === ImmerScope.current) {\n      ImmerScope.current = this.parent;\n    }\n  };\n\n  ImmerScope.enter = function (immer) {\n    var scope = new ImmerScope(ImmerScope.current, immer);\n    ImmerScope.current = scope;\n    return scope;\n  };\n\n  return ImmerScope;\n}();\n\nfunction revoke(draft) {\n  var state = draft[DRAFT_STATE];\n  if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) { state.revoke(); }else { state.revoked = true; }\n}\n\nfunction processResult(immer, result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  immer.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = finalize(immer, result, scope);\n      maybeFreeze(immer, result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = finalize(immer, baseDraft, scope, []);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n}\n\nfunction finalize(immer, draft, scope, path) {\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return finalizeTree(immer, draft, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    maybeFreeze(immer, state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (immer.onDelete && state.type !== ProxyType.Set) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (immer.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) { immer.onDelete(state, prop); }\n        });\n      } else {\n        var base = state.base,\n            copy_1 = state.copy;\n        each(base, function (prop) {\n          if (!has(copy_1, prop)) { immer.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (immer.onCopy) {\n      immer.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (immer.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n}\n\nfunction finalizeTree(immer, root, scope, rootPath) {\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  each(root, function (key, value) {\n    return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);\n  });\n  return root;\n}\n\nfunction finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {\n  if (childValue === parentValue) {\n    throw Error(\"Immer forbids circular references\");\n  } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n  var isDraftProp = !!rootState && parentValue === root;\n  var isSetMember = isSet(parentValue);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.\n    !has(rootState.assigned, prop) // Skip deep patches for assigned keys.\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n\n    childValue = finalize(immer, childValue, scope, path);\n    set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.\n\n    if (isDraft(childValue)) {\n      scope.canAutoFreeze = false;\n    }\n  } // Unchanged draft properties are ignored.\n  else if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n    // especially the passing on of root and rootState doesn't make sense...\n    else if (isDraftable(childValue) && !Object.isFrozen(childValue)) {\n        each(childValue, function (key, grandChild) {\n          return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);\n        });\n        maybeFreeze(immer, childValue);\n      }\n\n  if (isDraftProp && immer.onAssign && !isSetMember) {\n    immer.onAssign(rootState, prop, childValue);\n  }\n}\n\nfunction maybeFreeze(immer, value, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (immer.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n}\n\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,\n    // Track which produce call this is associated with.\n    scope: parent ? parent.scope : ImmerScope.current,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null,\n    isManual: false\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n  // and administrate revoking ourselves\n\n\n  var _a = Proxy.revocable(target, traps),\n      revoke = _a.revoke,\n      proxy = _a.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\nvar objectTraps = {\n  get: function (state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n      // @ts-ignore\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = state.scope.immer.createProxy(value, state);\n  },\n  has: function (state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function (state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function (state, prop\n  /* strictly not, but helps TS */\n  , value) {\n    if (!state.modified) {\n      var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    state.assigned[prop] = true; // @ts-ignore\n\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function (state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    } // @ts-ignore\n\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function (state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = state.type !== ProxyType.ProxyArray || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function () {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function (state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function () {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  // @ts-ignore\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n/**\r\n * Map drafts\r\n */\n// Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {\n      var copy_1 = state.copy = shallowCopy(state.base);\n      each(state.drafts, function (key, value) {\n        // @ts-ignore\n        copy_1[key] = value;\n      });\n      state.drafts = undefined;\n    }\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = shallowCopy(state.base);\n  }\n}\n\nfunction willFinalizeES5(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createES5Proxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  });\n  var state = {\n    type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,\n    scope: parent ? parent.scope : ImmerScope.current,\n    modified: false,\n    finalizing: false,\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoked: false,\n    isManual: false\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  return draft;\n} // Access a property without creating an Immer draft.\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek$1(latest(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek$1(state.base, prop) && isDraftable(value)) {\n    prepareCopy$1(state); // @ts-ignore\n\n    return state.copy[prop] = state.scope.immer.createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set$1(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek$1(latest(state), prop))) { return; }\n    markChangedES5(state);\n    prepareCopy$1(state);\n  } // @ts-ignore\n\n\n  state.copy[prop] = value;\n}\n\nfunction markChangedES5(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChangedES5(state.parent); }\n  }\n}\n\nfunction prepareCopy$1(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function () {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function (value) {\n        set$1(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      switch (state.type) {\n        case ProxyType.ES5Array:\n          if (hasArrayChanges(state)) { markChangedES5(state); }\n          break;\n\n        case ProxyType.ES5Object:\n          if (hasObjectChanges(state)) { markChangedES5(state); }\n          break;\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned,\n      type = state.type;\n\n  if (type === ProxyType.ES5Object) {\n    // Look for added keys.\n    // TODO: looks quite duplicate to hasObjectChanges,\n    // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n    // unnecessary work.\n    // also: probably we can store the information we detect here, to speed up tree finalization!\n    each(draft, function (key) {\n      if (key === DRAFT_STATE) { return; } // The `undefined` check is a fast path for pre-existing keys.\n\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChangedES5(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    each(base, function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChangedES5(state);\n      }\n    });\n  } else if (type === ProxyType.ES5Array && hasArrayChanges(state)) {\n    markChangedES5(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }\n    }\n\n    for (var i = 0; i < draft.length; i++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state_1 = value && value[DRAFT_STATE];\n\n        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nvar DraftMap = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Map is not polyfilled\");\n  }\n\n  __extends(DraftMap, _super); // Create class manually, cause #502\n\n\n  function DraftMap(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Map,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      assigned: undefined,\n      base: target,\n      draft: this,\n      isManual: false,\n      revoked: false\n    };\n    return this;\n  }\n\n  var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty\n\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (key) {\n    return latest(this[DRAFT_STATE]).has(key);\n  };\n\n  p.set = function (key, value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (latest(state).get(key) !== value) {\n      prepareCopy$2(state);\n      state.scope.immer.markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n      state.assigned.set(key, true);\n    }\n\n    return this;\n  };\n\n  p.delete = function (key) {\n    if (!this.has(key)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return true;\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned = new Map();\n\n    for (var _i = 0, _a = latest(state).keys(); _i < _a.length; _i++) {\n      var key = _a[_i];\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  };\n\n  p.forEach = function (cb, thisArg) {\n    var _this = this;\n\n    var state = this[DRAFT_STATE];\n    latest(state).forEach(function (_value, key, _map) {\n      cb.call(thisArg, _this.get(key), key, _this);\n    });\n  };\n\n  p.get = function (key) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    var value = latest(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value; // either already drafted or reassigned\n    } // despite what it looks, this creates a draft only once, see above condition\n\n\n    var draft = state.scope.immer.createProxy(value, state);\n    prepareCopy$2(state);\n    state.copy.set(key, draft);\n    return draft;\n  };\n\n  p.keys = function () {\n    return latest(this[DRAFT_STATE]).keys();\n  };\n\n  p.values = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.values();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) { return r; }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: value\n      };\n    }, _a;\n  };\n\n  p.entries = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.entries();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) { return r; }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: [r.value, value]\n      };\n    }, _a;\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.entries();\n  };\n\n  return DraftMap;\n}(Map);\n\nfunction proxyMap(target, parent) {\n  // @ts-ignore\n  return new DraftMap(target, parent);\n}\n\nfunction prepareCopy$2(state) {\n  if (!state.copy) {\n    state.assigned = new Map();\n    state.copy = new Map(state.base);\n  }\n}\n\nvar DraftSet = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Set is not polyfilled\");\n  }\n\n  __extends(DraftSet, _super); // Create class manually, cause #502\n\n\n  function DraftSet(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Set,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      base: target,\n      draft: this,\n      drafts: new Map(),\n      revoked: false,\n      isManual: false\n    };\n    return this;\n  }\n\n  var p = DraftSet.prototype;\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n\n    if (!state.copy) {\n      return state.base.has(value);\n    }\n\n    if (state.copy.has(value)) { return true; }\n    if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) { return true; }\n    return false;\n  };\n\n  p.add = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (state.copy) {\n      state.copy.add(value);\n    } else if (!state.base.has(value)) {\n      prepareCopy$3(state);\n      state.scope.immer.markChanged(state);\n      state.copy.add(value);\n    }\n\n    return this;\n  };\n\n  p.delete = function (value) {\n    if (!this.has(value)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :\n    /* istanbul ignore next */\n    false);\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.clear();\n  };\n\n  p.values = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.values();\n  };\n\n  p.entries = function entries() {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.entries();\n  };\n\n  p.keys = function () {\n    return this.values();\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.values();\n  };\n\n  p.forEach = function forEach(cb, thisArg) {\n    var iterator = this.values();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, this);\n      result = iterator.next();\n    }\n  };\n\n  return DraftSet;\n}(Set);\n\nfunction proxySet(target, parent) {\n  // @ts-ignore\n  return new DraftSet(target, parent);\n}\n\nfunction prepareCopy$3(state) {\n  if (!state.copy) {\n    // create drafts for all entries to preserve insertion order\n    state.copy = new Set();\n    state.base.forEach(function (value) {\n      if (isDraftable(value)) {\n        var draft = state.scope.immer.createProxy(value, state);\n        state.drafts.set(value, draft);\n        state.copy.add(draft);\n      } else {\n        state.copy.add(value);\n      }\n    });\n  }\n}\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  switch (state.type) {\n    case ProxyType.ProxyObject:\n    case ProxyType.ES5Object:\n    case ProxyType.Map:\n      return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n    case ProxyType.ES5Array:\n    case ProxyType.ProxyArray:\n      return generateArrayPatches(state, basePath, patches, inversePatches);\n\n    case ProxyType.Set:\n      return generateSetPatches(state, basePath, patches, inversePatches);\n  }\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var _a, _b;\n\n  var base = state.base,\n      assigned = state.assigned,\n      copy = state.copy;\n  /* istanbul ignore next */\n\n  if (!copy) { die(); } // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    _a = [copy, base], base = _a[0], copy = _a[1];\n    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i = end + delta - 1; i >= end; --i) {\n    var path = basePath.concat([i]);\n    patches[replaceCount + i - end] = {\n      op: \"add\",\n      path: path,\n      value: copy[i]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  var i = 0;\n  base.forEach(function (value) {\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n  i = 0;\n  copy.forEach(function (value) {\n    if (!base.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  patches.forEach(function (patch) {\n    var path = patch.path,\n        op = patch.op;\n    /* istanbul ignore next */\n\n    if (!path.length) { die(); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var type = getArchtype(base);\n    var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        switch (type) {\n          case Archtype.Map:\n            return base.set(key, value);\n\n          /* istanbul ignore next */\n\n          case Archtype.Set:\n            throw new Error('Sets cannot have \"replace\" patches.');\n\n          default:\n            // if value is an object, then it's assigned by reference\n            // in the following add or remove ops, the value field inside the patch will also be modifyed\n            // so we use value from the cloned patch\n            // @ts-ignore\n            return base[key] = value;\n        }\n\n      case \"add\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 0, value);\n\n          case Archtype.Map:\n            return base.set(key, value);\n\n          case Archtype.Set:\n            return base.add(value);\n\n          default:\n            return base[key] = value;\n        }\n\n      case \"remove\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 1);\n\n          case Archtype.Map:\n            return base.delete(key);\n\n          case Archtype.Set:\n            return base.delete(patch.value);\n\n          default:\n            return delete base[key];\n        }\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  });\n  return draft;\n}\n\nfunction deepClonePatchValue(obj) {\n  if (!obj || typeof obj !== \"object\") { return obj; }\n  if (Array.isArray(obj)) { return obj.map(deepClonePatchValue); }\n  if (isMap(obj)) { return new Map(Array.from(obj.entries()).map(function (_a) {\n    var k = _a[0],\n        v = _a[1];\n    return [k, deepClonePatchValue(v)];\n  })); } // Not needed: if (isSet(obj)) return new Set(Array.from(obj.values()).map(deepClone))\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = deepClonePatchValue(obj[key]); }\n\n  return cloned;\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\n/* istanbul ignore next */\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" :\n  /* istanbul ignore next */\n  verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer =\n/** @class */\nfunction () {\n  function Immer(config) {\n    var _this = this;\n\n    this.useProxies = false;\n    this.autoFreeze = false;\n    each(configDefaults, function (key, value) {\n      var _a, _b; // @ts-ignore\n\n\n      _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);\n    });\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n    this.produceWithPatches = this.produceWithPatches.bind(this);\n  }\n  /**\r\n   * The `produce` function takes a value and a \"recipe function\" (whose\r\n   * return value often depends on the base state). The recipe function is\r\n   * free to mutate its first argument however it wants. All mutations are\r\n   * only ever applied to a __copy__ of the base state.\r\n   *\r\n   * Pass only a function to create a \"curried producer\" which relieves you\r\n   * from passing the recipe function every time.\r\n   *\r\n   * Only plain objects and arrays are made mutable. All other objects are\r\n   * considered uncopyable.\r\n   *\r\n   * Note: This function is __bound__ to its `Immer` instance.\r\n   *\r\n   * @param {any} base - the initial state\r\n   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n   * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n   * @returns {any} a new state, or the initial state if nothing was modified\r\n   */\n\n\n  Immer.prototype.produce = function (base, recipe, patchListener) {\n    var _this = this; // curried invocation\n\n\n    if (typeof base === \"function\" && typeof recipe !== \"function\") {\n      var defaultBase_1 = recipe;\n      recipe = base;\n      var self_1 = this;\n      return function curriedProduce(base) {\n        var arguments$1 = arguments;\n\n        var _this = this;\n\n        if (base === void 0) {\n          base = defaultBase_1;\n        }\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return self_1.produce(base, function (draft) {\n          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));\n        }); // prettier-ignore\n      };\n    } // prettier-ignore\n\n\n    {\n      if (typeof recipe !== \"function\") {\n        throw new Error(\"The first or second argument to `produce` must be a function\");\n      }\n\n      if (patchListener !== undefined && typeof patchListener !== \"function\") {\n        throw new Error(\"The third argument to `produce` must be a function or undefined\");\n      }\n    }\n    var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n    if (isDraftable(base)) {\n      var scope_1 = ImmerScope.enter(this);\n      var proxy = this.createProxy(base, undefined);\n      var hasError = true;\n\n      try {\n        result = recipe(proxy);\n        hasError = false;\n      } finally {\n        // finally instead of catch + rethrow better preserves original stack\n        if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }\n      }\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (result) {\n          scope_1.usePatches(patchListener);\n          return processResult(_this, result, scope_1);\n        }, function (error) {\n          scope_1.revoke();\n          throw error;\n        });\n      }\n\n      scope_1.usePatches(patchListener);\n      return processResult(this, result, scope_1);\n    } else {\n      result = recipe(base);\n      if (result === NOTHING) { return undefined; }\n      if (result === undefined) { result = base; }\n      maybeFreeze(this, result, true);\n      return result;\n    }\n  };\n\n  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {\n    var _this = this;\n\n    if (typeof arg1 === \"function\") {\n      return function (state) {\n        var arguments$1 = arguments;\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return _this.produceWithPatches(state, function (draft) {\n          return arg1.apply(void 0, __spreadArrays([draft], args));\n        });\n      };\n    } // non-curried form\n\n    /* istanbul ignore next */\n\n\n    if (arg3) { die(); }\n    var patches, inversePatches;\n    var nextState = this.produce(arg1, arg2, function (p, ip) {\n      patches = p;\n      inversePatches = ip;\n    });\n    return [nextState, patches, inversePatches];\n  };\n\n  Immer.prototype.createDraft = function (base) {\n    if (!isDraftable(base)) {\n      throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n    }\n\n    var scope = ImmerScope.enter(this);\n    var proxy = this.createProxy(base, undefined);\n    proxy[DRAFT_STATE].isManual = true;\n    scope.leave();\n    return proxy;\n  };\n\n  Immer.prototype.finishDraft = function (draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    if (!state || !state.isManual) {\n      throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n    }\n\n    if (state.finalized) {\n      throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n    }\n\n    var scope = state.scope;\n    scope.usePatches(patchListener);\n    return processResult(this, undefined, scope);\n  };\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is disabled in production.\r\n   */\n\n\n  Immer.prototype.setAutoFreeze = function (value) {\n    this.autoFreeze = value;\n  };\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n\n\n  Immer.prototype.setUseProxies = function (value) {\n    this.useProxies = value;\n  };\n\n  Immer.prototype.applyPatches = function (base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatches(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatches(draft, patches.slice(i + 1));\n    });\n  };\n\n  Immer.prototype.createProxy = function (value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);\n    var scope = parent ? parent.scope : ImmerScope.current;\n    scope.drafts.push(draft);\n    return draft;\n  };\n\n  Immer.prototype.willFinalize = function (scope, thing, isReplaced) {\n    if (!this.useProxies) { willFinalizeES5(scope, thing, isReplaced); }\n  };\n\n  Immer.prototype.markChanged = function (state) {\n    if (this.useProxies) {\n      markChanged(state);\n    } else {\n      markChangedES5(state);\n    }\n  };\n\n  return Immer;\n}();\n\nvar immer = new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * By default, auto-freezing is disabled in production.\r\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n"],"sourceRoot":""}