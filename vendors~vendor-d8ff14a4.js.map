{"version":3,"sources":["webpack:///./node_modules/immer/dist/immer.module.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","_a","NOTHING","Symbol","DRAFTABLE","DRAFT_STATE","isDraft","value","isDraftable","isArray","proto","Object","getPrototypeOf","prototype","isPlainObject","constructor","isMap","isSet","original","base","assign","target","arguments$1","overrides","_i","forEach","override","keys","key","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","Map","Set","clone","create","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","iter","entry","index","isEnumerable","prop","has","thing","hasOwnProperty","is","x","y","hasSymbol","hasMap","hasSet","makeIterable","next","self","iterator","iterateMapValues","state","receiver","isEntries","latest","result","done","makeIterateSetValues","createProxy","draft","drafts","finalized","finalizing","set","modified","copy","add","wrapSetValue","map","cloned","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","_","ImmerScope","parent","this","canAutoFreeze","patches","usePatches","patchListener","inversePatches","revoke","leave","current","enter","scope","clonePotentialDraft","defineProperties","mapTraps","proxyMethod","setTraps","iterateSetValues","proxySet","descriptors","assertUnrevoked","peek","latest$1","prepareCopy","get$1","assigned","markChanged","proxyProperty","revoke$1","revoked","createHiddenProperty","push","finalizeTraps","size","reciever","cb","values","entries","thisArg","traps","reduce","acc","builder","proxyAttr","fn","trap","args","apply","JSON","stringify","markChangesSweep","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","baseValue","undefined","state_1","descriptor","hasChanges","_a$1","_b","legacyProxy","__proto__","willFinalize","isReplaced","markChangesRecursively","object","createProxy$1","objectTraps","arrayTraps","mapTraps$1","setTraps$1","Proxy","revocable","proxy","latest$2","peek$1","markChanged$1","deleteProperty","owner","setPrototypeOf","isNaN","parseInt","reflectTraps","name","makeTrapsForGetters","value_1","draft_1","iterateSetValues$1","prev","assignMap","getters","modernProxy","generateArrayPatches","basePath","delta","start","end","path","op","replaceCount","generatePatchesFromAssigned","assignedValue","origValue","generateSetPatches","unshift","applyPatches","patch","join","splice","configDefaults","useProxies","autoFreeze","process","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","_this","defaultBase_1","self_1","scope_1","hasError","Promise","then","processResult","error","maybeFreeze","arg1","arg2","arg3","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","finalizeTree","exists","copy_1","generatePatches","root","rootPath","needPatches","finalizeProperty","isDraftProp","isSetMember","replace","immer","applyPatches$1"],"mappings":"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","file":"vendors~vendor-d8ff14a4.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\nvar _a;\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (_a = {}, _a[\"immer-nothing\"] = true, _a);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol[\"for\"] ? Symbol[\"for\"](\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol[\"for\"] ? Symbol[\"for\"](\"immer-state\") : \"__$immer_state\";\n/** Returns true if the given value is an Immer draft */\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n/** Get the underlying object that is represented by the given draft */\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) { target[\"delete\"](prev); } // @ts-ignore TODO investigate\n\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\nvar assign = Object.assign || function (target) {\n  var arguments$1 = arguments;\n\n  var overrides = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    overrides[_i - 1] = arguments$1[_i];\n  }\n\n  overrides.forEach(function (override) {\n    if (typeof override === \"object\" && override !== null) { Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    }); }\n  });\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) {\n    invokeGetters = false;\n  }\n\n  if (Array.isArray(base)) { return base.slice(); }\n  if (isMap(base)) { return new Map(base); }\n  if (isSet(base)) { return new Set(base); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return desc && desc.enumerable ? true : false;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var _a;\n\n  var self;\n  return self = (_a = {}, _a[Symbol.iterator] = function () {\n    return self;\n  }, _a.next = next, _a);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var key = result.value[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  if (isMap(obj)) { return new Map(obj); }\n  if (isSet(obj)) { return new Set(obj); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj[\"delete\"] = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj[\"delete\"] = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) {\n    return freeze(value, true);\n  }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope =\n/** @class */\nfunction () {\n  function ImmerScope(parent) {\n    this.drafts = [];\n    this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n\n    this.canAutoFreeze = true; // To avoid prototype lookups:\n\n    this.patches = null; // TODO:\n  }\n\n  ImmerScope.prototype.usePatches = function (patchListener) {\n    if (patchListener) {\n      this.patches = [];\n      this.inversePatches = [];\n      this.patchListener = patchListener;\n    }\n  };\n\n  ImmerScope.prototype.revoke = function () {\n    this.leave();\n    this.drafts.forEach(revoke); // @ts-ignore\n\n    this.drafts = null; // TODO: // Make draft-related methods throw.\n  };\n\n  ImmerScope.prototype.leave = function () {\n    if (this === ImmerScope.current) {\n      ImmerScope.current = this.parent;\n    }\n  };\n\n  ImmerScope.enter = function () {\n    var scope = new ImmerScope(ImmerScope.current);\n    ImmerScope.current = scope;\n    return scope;\n  };\n\n  return ImmerScope;\n}();\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function () {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function (value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, // @ts-ignore\n    proxyMethod(iterateMapValues) //TODO: , Symbol.iterator)\n    );\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function (state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n\n      return state.draft;\n    };\n  },\n  \"delete\": function (state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy[\"delete\"](key);\n      return false;\n    };\n  },\n  clear: function (state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      markChanged(state);\n      state.assigned = new Map();\n\n      for (var _i = 0, _a = latest$1(state).keys(); _i < _a.length; _i++) {\n        var key = _a[_i];\n        state.assigned.set(key, false);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  forEach: function (state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function (state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function (state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, // @ts-ignore\n    proxyMethod(iterateSetValues) //TODO: , Symbol.iterator)\n    );\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n\n        state.copy.add(value);\n      }\n\n      return state.draft;\n    };\n  },\n  \"delete\": function (state) {\n    return function (value) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy[\"delete\"](value);\n    };\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function (state) {\n    return function () {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function () {\n      return function () {\n        var arguments$1 = arguments;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments$1[_i];\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) { markChanged(state); }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }\n    }\n\n    for (var i = 0; i < draft.length; i++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state_1 = value && value[DRAFT_STATE];\n\n        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base,\n      draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base,\n      draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    willFinalize: willFinalize,\n    createProxy: createProxy\n});\n\nvar _a$1, _b;\n\nfunction willFinalize$1() {}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var _a = Proxy.revocable(target, traps),\n      revoke = _a.revoke,\n      proxy = _a.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\nvar objectTraps = {\n  get: function (state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function (state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function (state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function (state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function (state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function (state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function () {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function (state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function () {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\r\n * Map drafts\r\n */\n\nvar mapTraps$1 = makeTrapsForGetters((_a$1 = {}, _a$1[DRAFT_STATE] = function (state) {\n  return state;\n}, _a$1.size = function (state) {\n  return latest$2(state).size;\n}, _a$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, _a$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state); // @ts-ignore\n\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  };\n}, _a$1[\"delete\"] = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state); // @ts-ignore\n\n      state.assigned.set(key, false);\n      return state.copy[\"delete\"](key);\n    }\n\n    return false;\n  };\n}, _a$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n    each(latest$2(state).keys(), function (_, key) {\n      // @ts-ignore\n      state.assigned.set(key, false);\n    });\n    return state.copy.clear();\n  };\n}, // @ts-ignore\n_a$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, _a$1.get = function (state) {\n  return function (key) {\n    var drafts = state.modified ? state.copy : state.drafts; // @ts-ignore TODO: ...or fix by using different ES6Draft types (but better just unify to maps)\n\n    if (drafts.has(key)) {\n      // @ts-ignore\n      var value_1 = drafts.get(key);\n      if (isDraft(value_1) || !isDraftable(value_1)) { return value_1; }\n      var draft_1 = createProxy$1(value_1, state); // @ts-ignore\n\n      drafts.set(key, draft_1);\n      return draft_1;\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state); //@ts-ignore\n\n    drafts.set(key, draft);\n    return draft;\n  };\n}, _a$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, //@ts-ignore\n_a$1.values = iterateMapValues, //@ts-ignore\n_a$1.entries = iterateMapValues, _a$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, _a$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\r\n * Set drafts\r\n */\n\nvar setTraps$1 = makeTrapsForGetters((_b = {}, //@ts-ignore\n_b[DRAFT_STATE] = function (state) {\n  return state;\n}, _b.size = function (state) {\n  return latest$2(state).size;\n}, _b.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, _b.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state); //@ts-ignore\n\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  };\n}, _b[\"delete\"] = function (state) {\n  return function (value) {\n    markChanged$1(state); //@ts-ignore\n\n    return state.copy[\"delete\"](value);\n  };\n}, _b.clear = function (state) {\n  return function () {\n    markChanged$1(state); //@ts-ignore\n\n    return state.copy.clear();\n  };\n}, _b.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, _b.keys = iterateSetValues$1, _b.values = iterateSetValues$1, _b.entries = iterateSetValues$1, _b[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, _b));\n/**\r\n * Helpers\r\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base,\n        drafts = state.drafts,\n        parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) { assignMap(copy, drafts); }else { assign(copy, drafts); }\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    // @ts-ignore\n    traps[name] = function (state) {\n      var arguments$1 = arguments;\n\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments$1[_i];\n      }\n\n      return Reflect[name].apply(Reflect, __spreadArrays([latest$2(state)], args));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return assign({}, reflectTraps, {\n    get: function (state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function (state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    willFinalize: willFinalize$1,\n    createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var _a, _b;\n\n  var base = state.base,\n      copy = state.copy,\n      assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    _a = [copy, base], base = _a[0], copy = _a[1];\n    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i = end + delta - 1; i >= end; --i) {\n    var path = basePath.concat([i]);\n    patches[replaceCount + i - end] = {\n      op: \"add\",\n      path: path,\n      value: copy[i]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  var i = 0;\n  base.forEach(function (value) {\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n  i = 0;\n  copy.forEach(function (value) {\n    if (!base.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  patches.forEach(function (patch) {\n    var path = patch.path,\n        op = patch.op;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base[\"delete\"](patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base[\"delete\"](key) : isSet(base) ? base[\"delete\"](patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  });\n  return draft;\n}\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer =\n/** @class */\nfunction () {\n  function Immer(config) {\n    this.useProxies = false;\n    this.autoFreeze = false;\n    assign(this, configDefaults, config);\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n    this.produceWithPatches = this.produceWithPatches.bind(this);\n  }\n  /**\r\n   * The `produce` function takes a value and a \"recipe function\" (whose\r\n   * return value often depends on the base state). The recipe function is\r\n   * free to mutate its first argument however it wants. All mutations are\r\n   * only ever applied to a __copy__ of the base state.\r\n   *\r\n   * Pass only a function to create a \"curried producer\" which relieves you\r\n   * from passing the recipe function every time.\r\n   *\r\n   * Only plain objects and arrays are made mutable. All other objects are\r\n   * considered uncopyable.\r\n   *\r\n   * Note: This function is __bound__ to its `Immer` instance.\r\n   *\r\n   * @param {any} base - the initial state\r\n   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n   * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n   * @returns {any} a new state, or the initial state if nothing was modified\r\n   */\n\n\n  Immer.prototype.produce = function (base, recipe, patchListener) {\n    var _this = this; // curried invocation\n\n\n    if (typeof base === \"function\" && typeof recipe !== \"function\") {\n      var defaultBase_1 = recipe;\n      recipe = base;\n      var self_1 = this;\n      return function curriedProduce(base) {\n        var arguments$1 = arguments;\n\n        var _this = this;\n\n        if (base === void 0) {\n          base = defaultBase_1;\n        }\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return self_1.produce(base, function (draft) {\n          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));\n        }); // prettier-ignore\n      };\n    } // prettier-ignore\n\n\n    {\n      if (typeof recipe !== \"function\") {\n        throw new Error(\"The first or second argument to `produce` must be a function\");\n      }\n\n      if (patchListener !== undefined && typeof patchListener !== \"function\") {\n        throw new Error(\"The third argument to `produce` must be a function or undefined\");\n      }\n    }\n    var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n    if (isDraftable(base)) {\n      var scope_1 = ImmerScope.enter();\n      var proxy = this.createProxy(base);\n      var hasError = true;\n\n      try {\n        result = recipe(proxy);\n        hasError = false;\n      } finally {\n        // finally instead of catch + rethrow better preserves original stack\n        if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }\n      }\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (result) {\n          scope_1.usePatches(patchListener);\n          return _this.processResult(result, scope_1);\n        }, function (error) {\n          scope_1.revoke();\n          throw error;\n        });\n      }\n\n      scope_1.usePatches(patchListener);\n      return this.processResult(result, scope_1);\n    } else {\n      result = recipe(base);\n      if (result === NOTHING) { return undefined; }\n      if (result === undefined) { result = base; }\n      this.maybeFreeze(result, true);\n      return result;\n    }\n  };\n\n  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {\n    var _this = this;\n\n    if (typeof arg1 === \"function\") {\n      return function (state) {\n        var arguments$1 = arguments;\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return _this.produceWithPatches(state, function (draft) {\n          return arg1.apply(void 0, __spreadArrays([draft], args));\n        });\n      };\n    } // non-curried form\n\n\n    if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n    var patches, inversePatches;\n    var nextState = this.produce(arg1, arg2, function (p, ip) {\n      patches = p;\n      inversePatches = ip;\n    });\n    return [nextState, patches, inversePatches];\n  };\n\n  Immer.prototype.createDraft = function (base) {\n    if (!isDraftable(base)) {\n      throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n    }\n\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    proxy[DRAFT_STATE].isManual = true;\n    scope.leave();\n    return proxy;\n  };\n\n  Immer.prototype.finishDraft = function (draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    if (!state || !state.isManual) {\n      throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n    }\n\n    if (state.finalized) {\n      throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n    }\n\n    var scope = state.scope;\n    scope.usePatches(patchListener);\n    return this.processResult(undefined, scope);\n  };\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is disabled in production.\r\n   */\n\n\n  Immer.prototype.setAutoFreeze = function (value) {\n    this.autoFreeze = value;\n  };\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n\n\n  Immer.prototype.setUseProxies = function (value) {\n    this.useProxies = value;\n    assign(this, value ? modernProxy : legacyProxy);\n  };\n\n  Immer.prototype.applyPatches = function (base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatches(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatches(draft, patches.slice(i + 1));\n    });\n  };\n  /** @internal */\n\n\n  Immer.prototype.processResult = function (result, scope) {\n    var baseDraft = scope.drafts[0];\n    var isReplaced = result !== undefined && result !== baseDraft;\n    this.willFinalize(scope, result, isReplaced);\n\n    if (isReplaced) {\n      if (baseDraft[DRAFT_STATE].modified) {\n        scope.revoke();\n        throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n      }\n\n      if (isDraftable(result)) {\n        // Finalize the result in case it contains (or is) a subset of the draft.\n        result = this.finalize(result, null, scope);\n        this.maybeFreeze(result);\n      }\n\n      if (scope.patches) {\n        scope.patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        scope.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseDraft[DRAFT_STATE].base\n        });\n      }\n    } else {\n      // Finalize the base draft.\n      result = this.finalize(baseDraft, [], scope);\n    }\n\n    scope.revoke();\n\n    if (scope.patches) {\n      scope.patchListener(scope.patches, scope.inversePatches);\n    }\n\n    return result !== NOTHING ? result : undefined;\n  };\n  /**\r\n   * @internal\r\n   * Finalize a draft, returning either the unmodified base state or a modified\r\n   * copy of the base state.\r\n   */\n\n\n  Immer.prototype.finalize = function (draft, path, scope) {\n    var _this = this;\n\n    var state = draft[DRAFT_STATE];\n\n    if (!state) {\n      if (Object.isFrozen(draft)) { return draft; }\n      return this.finalizeTree(draft, null, scope);\n    } // Never finalize drafts owned by another scope.\n\n\n    if (state.scope !== scope) {\n      return draft;\n    }\n\n    if (!state.modified) {\n      this.maybeFreeze(state.base, true);\n      return state.base;\n    }\n\n    if (!state.finalized) {\n      state.finalized = true;\n      this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n      if (this.onDelete && !isSet(state.base)) {\n        // The `assigned` object is unreliable with ES5 drafts.\n        if (this.useProxies) {\n          var assigned = state.assigned;\n          each(assigned, function (prop, exists) {\n            var _a, _b;\n\n            if (!exists) { (_b = (_a = _this).onDelete) === null || _b === void 0 ? void 0 : _b.call(_a, state, prop); }\n          });\n        } else {\n          // TODO: Figure it out for Maps and Sets if we need to support ES5\n          var base = state.base,\n              copy_1 = state.copy;\n          each(base, function (prop) {\n            var _a, _b;\n\n            if (!has(copy_1, prop)) { (_b = (_a = _this).onDelete) === null || _b === void 0 ? void 0 : _b.call(_a, state, prop); }\n          });\n        }\n      }\n\n      if (this.onCopy) {\n        this.onCopy(state);\n      } // At this point, all descendants of `state.copy` have been finalized,\n      // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n      if (this.autoFreeze && scope.canAutoFreeze) {\n        freeze(state.copy, false);\n      }\n\n      if (path && scope.patches) {\n        generatePatches(state, path, scope.patches, scope.inversePatches);\n      }\n    }\n\n    return state.copy;\n  };\n  /**\r\n   * @internal\r\n   * Finalize all drafts in the given state tree.\r\n   */\n\n\n  Immer.prototype.finalizeTree = function (root, rootPath, scope) {\n    var _this = this;\n\n    var state = root[DRAFT_STATE];\n\n    if (state) {\n      if (!this.useProxies) {\n        // Create the final copy, with added keys and without deleted keys.\n        state.copy = shallowCopy(state.draft, true);\n      }\n\n      root = state.copy;\n    }\n\n    var needPatches = !!rootPath && !!scope.patches;\n\n    var finalizeProperty = function (prop, value, parent) {\n      if (value === parent) {\n        throw Error(\"Immer forbids circular references\");\n      } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n      var isDraftProp = !!state && parent === root;\n      var isSetMember = isSet(parent);\n\n      if (isDraft(value)) {\n        var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n        !has(state.assigned, prop) // Skip deep patches for assigned keys.\n        ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n        value = _this.finalize(value, path, scope);\n        replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n        if (isDraft(value)) {\n          scope.canAutoFreeze = false;\n        } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n        if (isDraftProp && value === get(state.base, prop)) { return; }\n      } // Unchanged draft properties are ignored.\n      else if (isDraftProp && is(value, get(state.base, prop))) {\n          return;\n        } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n        else if (isDraftable(value) && !Object.isFrozen(value)) {\n            each(value, finalizeProperty);\n\n            _this.maybeFreeze(value);\n          }\n\n      if (isDraftProp && _this.onAssign && !isSetMember) {\n        _this.onAssign(state, prop, value);\n      }\n    };\n\n    each(root, finalizeProperty);\n    return root;\n  };\n\n  Immer.prototype.maybeFreeze = function (value, deep) {\n    if (deep === void 0) {\n      deep = false;\n    }\n\n    if (this.autoFreeze && !isDraft(value)) {\n      freeze(value, deep);\n    }\n  };\n\n  return Immer;\n}();\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent[\"delete\"](prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * By default, auto-freezing is disabled in production.\r\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n"],"sourceRoot":""}